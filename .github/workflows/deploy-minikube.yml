name: Local Deploy to Minikube (hybrid)

on:
  push:
    branches:
      - main
      - dev
      - master
      - pipelines
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: self-hosted

    env:
      COMPOSE_FILE: ./compose.yml
      LOAD_SCRIPT: ./load-images-minikube.bat
      K8S_MANIFEST: ./kubernetes
      NAMESPACE: ecommerce

    steps:
      # ğŸ§¾ Obtener el cÃ³digo del repositorio
      - name: Checkout repository
        uses: actions/checkout@v4

      # âš™ï¸ Configurar kubectl
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # ğŸ§© Verificar si Minikube estÃ¡ corriendo
      - name: Ensure Minikube is running
        shell: pwsh
        run: |
          $status = minikube status --format '{{.Host}}' 2>$null
          if ($status -ne 'Running') {
            Write-Host "ğŸš€ Minikube no estÃ¡ corriendo. Iniciando..."
            minikube start
          } else {
            Write-Host "âœ… Minikube ya estÃ¡ en ejecuciÃ³n."
          }

      # ğŸ§  Verificar estado de los pods
      - name: Check if pods are ready
        id: check_pods
        shell: pwsh
        run: |
          $ErrorActionPreference = 'SilentlyContinue'
          $pods = kubectl get pods -n $env:NAMESPACE --no-headers 2>$null
          if ($pods -and ($pods -notmatch "0/") -and ($pods -match "Running")) {
            Write-Host "âœ… Todos los pods estÃ¡n en estado Running y listos. Saltando despliegue."
            Add-Content -Path $env:GITHUB_OUTPUT -Value "skip=true"
          } else {
            Write-Host "ğŸš€ Algunos pods no estÃ¡n listos. Procediendo con el despliegue."
            Add-Content -Path $env:GITHUB_OUTPUT -Value "skip=false"
          }

      # ğŸ—ï¸ ConstrucciÃ³n de imÃ¡genes Docker
      - name: Build Docker images
        if: steps.check_pods.outputs.skip == 'false'
        shell: pwsh
        run: docker compose -f $env:COMPOSE_FILE build

      # ğŸ“¦ Cargar imÃ¡genes en Minikube
      - name: Load images into Minikube
        if: steps.check_pods.outputs.skip == 'false'
        shell: pwsh
        run: |
          Write-Host "ğŸ”„ Ejecutando script de carga: $env:LOAD_SCRIPT"
          & $env:LOAD_SCRIPT

      - name: Show Minikube images
        if: steps.check_pods.outputs.skip == 'false'
        shell: pwsh
        run: |
          Write-Host "ğŸ–¼ï¸  ImÃ¡genes presentes en Minikube:"
          minikube image ls

      # ğŸ·ï¸ Asegurar que la namespace existe (idempotente)
      - name: Ensure namespace exists
        if: steps.check_pods.outputs.skip == 'false'
        shell: pwsh
        run: |
          Write-Host "ğŸ” Asegurando namespace: $env:NAMESPACE"
          # Crear la namespace de forma idempotente (no falla si ya existe)
          kubectl create namespace $env:NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

      # ğŸš¢ Despliegue a Kubernetes
      - name: Deploy to Kubernetes
        if: steps.check_pods.outputs.skip == 'false'
        shell: pwsh
        run: |
          Write-Host "ğŸ“¦ Aplicando manifiestos desde: $env:K8S_MANIFEST"
          kubectl apply -f $env:K8S_MANIFEST

      # â³ Esperar que los despliegues se apliquen correctamente
      - name: Wait for deployments rollout
        if: steps.check_pods.outputs.skip == 'false'
        shell: pwsh
        run: |
          $deps = kubectl get deployments -n $env:NAMESPACE -o jsonpath="{.items[*].metadata.name}"
          foreach ($d in $deps.Split(' ')) {
            if ($d) {
              Write-Host "â³ Esperando rollout de $d..."
              kubectl rollout status deployment/$d -n $env:NAMESPACE --timeout=3m
            }
          }

      # ğŸ” Verificar estado final de los pods
      - name: Verify pods status
        run: kubectl get pods -n $env:NAMESPACE
